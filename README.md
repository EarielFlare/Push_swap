# Push_swap
Project push_swap with checker for School42.

Проект состоит из двух частей: push_swap и checker. Оба бинарника компилируются одним Makefile, командами push_swap, checker (bonus) - отдельно каждый файл, и all - оба сразу. Файлы раскиданы по папкам, headers лежат отдельно. При повторной сборке не происходит перекомпиляции файлов, но происходит перелинковка (не знаю почему).

В проекте используются циклические двусвязные списки. Основа обоих бинарников - функции работы с этими списками, реализованные на их основе инструкции из subject, а также парсер данных, распознающий даже сложные комбинации чисел в составе строк с помощью split.

Push_swap применяет для работы алгоритм быстрой сортировки (https://vk.com/@forum42intra-push-swap), однако мне не удалось поднять его эффективность выше оценки 4. Для сортировки 100 чисел необходимо около 800-860 инструкций, а для 500 чисел около 6000-6200 инструкций. На 6 числах и менее отрабатывают функции оптимизации сортировки, благодаря чему для 5 чисел количество инструкций не превышает 11.

Основа алгоритма - индексация всего списка (индексы означают место конкретного элемента списка в будущем остортированном стеке). После индексации весь объем чисел разделяется на два стека относительно среднего значения: в стеке A остаются числа больше среднего, в стек B уходят числа меньше среднего (включая среднее). После работа происходит со стеком B: в нем точно так же находят среднее значение, после чего половину чисел меньше среднего (включая среднее) оставляют в стеке B, а половину чисел больше среднего перекидывают обратно в стек A, наверх. Таких итераций может быть множество, поэтому каждый раз при пополнении стека A новой партией чисел им присваивается новое значение параметра group (от 1 и выше). По окончании работы со стеком B в нем остаются 3 числа, которые сортируются и переносятся вниз стека A функцией оптимизации. По окончании работы со стеком B (когда он пуст), в него перекидывается верхняя (крайняя) группа из стека A, после чего происходит обработка по описанному выше алгоритму. Для отслеживания текущего элемента, который необходимо отправить вниз стека A, используется параметр nextpoint. Таким образом, отсортированный массив данных скапливается внизу стека A. Все данные хранятся в структурах.

UPD: возможно, недостаточно высокая эффективность алгоритма связана с тем, что при работе с полученными группами чисел я не провожу их сортировку при перекидывании из стека A в стек B (просто перекидываю их в стек B), и таким образом, упускаю эту возможность. Наверное, если сортировку вести уже при перекидывании группы чисел в стек B, алгоритм удалось бы сделать оптимальнее..

Checker построен на основе push-swap (работа со списками и парсинг данных). В него добавлен экзаменационный get_next_line для считывания данных (на стековых переменных, без malloc) и функция проверки результата (отсортирован или нет).

По сути, вся сложность проекта заключается в написании оптимального алгоритма сортировки данных. Остальная часть, как например работа со списками, должна быть просто сделана и все. Использовать именно двусвязные циклические списки необязательно, можно обойтись функциями из libft. Для моего варианта мне пришлось писать свои функции работы со связанными списками.
